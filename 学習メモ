✅9/25【Next.jsで学ぶReact講座 #14】
イミュータブルや破壊的メソッドを理解しよう！スプレッド構文を使う理由とは！？

##JSの値にはミュータブルとイミュータブルについて
- ミュータブル：変更可能なオブジェクト
- イミュータブル：変更不可能なオブジェクト（推奨✨）

⭐️JSは配列とオブジェクトはミュータブル、文字列はイミュータブル
破壊的メソッドは避けて、イミュータブルなメソッドを使うことが望ましい
そのためにスプレッド構文やmapメソッドを使う

##Reactにおいてもイミュータブルな値を使うことが推奨されている
破壊的メソッドは、再レンダリングが行われないため、Reactのパフォーマンスが悪くなる

  const handleAdd = useCallback(() => {
    setArray((prevArray) => {
      const newArray = prevArray;
      newArray.push(1);
      console.log(newArray === prevArray); //true

      ↑この場合、新しい配列を作成していないため、同じ配列を参照している
      ⭐️newArrayは、prevArrayと同じ配列を参照しているため、Reactは再レンダリングを行わない

      return newArray;
    });
  }, []);

📝someメソッドとは？
配列の中に条件に合致する要素があるかどうかを判定するメソッド


✅9/26【Next.jsで学ぶReact講座 #15】
Custom Hooks（カスタムフック）の使い方、使いどころをマスターしよう！

##Custom Hooks（カスタムフック）とは？
-複数のコンポーネントで同じ処理を行う場合、Custom Hooksを使うことで、処理を共通化できる
-関数名をuse〜とすることで、Hooksとして認識される


✅10/3【Next.jsで学ぶReact講座 #17】
useMemoの使い方、useRouterの使い方

##useMemoとは？
-計算量の多い処理を最適化するためのHooks
-第一引数に計算式、第二引数に依存する値を指定する
  計算⭐︎結果⭐︎をキャッシュする！！
useCallbackとの違い：useCallbackは関数をキャッシュする

  const doubleCount = useMemo(() => {
    return count * 2;
  }, [count]);

  ↑countが変更された場合のみ、再計算される


##useRouterとは？
-Next.jsのHooks
-URLパラメータやクエリパラメータを取得するためのHooks
-Next.jsのページコンポーネント内でのみ使用可能

  const router = useRouter();
  const { id } = router.query;

  ↑URLパラメータを取得する場合、router.queryを使用する

router.pathname：現在のURLのパス名を取得
router.query：クエリパラメータを取得
router.push()：ページ遷移を行う
router.back()：前のページに戻る
router.prefetch()：ページの事前読み込みを行う

などなど色々あるので、公式ドキュメントを参照すると良い📚

✅10/4【Next.jsで学ぶReact講座 #18】
ReactでAPIを叩こう！Next.jsのESLintの設定もついでに紹介！

##APIを叩く方法
-ReactでAPIを叩く方法は、fetchメソッドを使用する
-useCallbackを使って非同期処理を行う

  const getPosts = useCallback(async () => {
    const res = await fetch("https://jsonplaceholder.typicode.com/posts");
    const json = await res.json();
    setPosts(json);
  }, []);

  ↑useCallbackの第二引数に空の配列を指定することで、初回レンダリング時のみ実行される

 ⭐︎初期値を指定しないとエラーになる------↓
 const [posts, setPosts] = useState([]);

 

✅10/6【Next.jsで学ぶReact講座 #19】
非同期処理で必要になるローディングとエラーの処理について学ぼう

##非同期処理で必要になるローディングとエラーの処理
--try-catch文を使ってエラー処理を行う

  const getPosts = useCallback(async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      const json = await res.json();
      setPosts(json);
    } catch (error) {
      console.error(error);
    }finaly{
      setLoading(false);
    }
  }, []);

  ↑try内でエラーが発生した場合、catch内の処理が実行される
  finaly内の処理は、try-catch文の処理が終了した後に実行される


✅10/7【Next.jsで学ぶReact講座 #20】
useReducerの使い方を学ぼ

  //Stateを一つにまとめる
  //⭐︎関数を使って前の値を取得する
  //スプレッド構文で展開して、新しい値を追加する

    ...prevState：
  既存のStateを展開する
  
    data: [],
    loading: true,
    error: null,

  setState((prevState) => {
    return {
      ...prevState,
      data: json,
      loading: false,
  
    };
  });

  ↑スプレッド演算子を使うことでdataの値だけを更新する場合、他の値はそのままになる
  ⭐︎書き換えたい値だけを更新することができる

  ##useReducerとは？
  -Stateを一つにまとめるHooks
  -前のStateを取得して、新しいStateを返す関数を使う時に好ましい

  -dispatch関数を使って、Stateを更新する
  下位コンポーネントにStateを渡す場合、useReducerを使うとパフォーマンスが向上する

  (satate,action) => newState
　⭐︎stateとactionを受け取って新しいstateを作る！！



const reducer = (state, action) => {
  switch (action.type) {
    case "end":
      return {
        ...state,
        data: action.data,
        loading: false,
      };

    case "error":
      return {
        ...state,
        error: action.error,
        loading: false,
      };

    default:
      throw new Error("no such action type!");
  }
};

reducer？？
-前のStateとactionを受け取って、新しいStateを返す関数（大事）
dispatch関数を使って、Stateを更新する
